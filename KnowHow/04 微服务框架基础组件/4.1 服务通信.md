#### 服务通信

网络通信是任何分布式系统的基础组件，对于微服务而言，网络通信关注于网络连接、IO、模型、可靠性设计以及服务调用方式。

##### 1. 网络连接

一般，基于TCP网络连接有两种基本方式，也就是我们常说的长连接和短连接，连接的建立需要三次握手，释放需要四次握手，而每次连接都意味着资源和时间的消耗。

三次建立握手示意图如下：

![TCP三次握手](..\00 common\images\03\TCP三次握手.png)

注：1.TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。

​       2.TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。

四次释放握手示意图如下：

![四次释放握手](..\00 common\images\03\四次释放握手.png)

注：1. TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。

​       2.服务器结束TCP连接的时间要比客户端早一些。

而且，一般短连接只会在客户端/服务器端间传递一次读写操作，存在的连接都是有用的连接，不需要额外的控制手段。而长连接则与其不同，当客户端与服务端完成一次读写操作后他们的连接不会主动关闭，用于后续的读写操作。注意，长连接和短连接的产生在于客户端和服务端所采取的关闭策略，具体的应用场景采用何种策略需要依据情况具体分析，没有十全十美的选择，只有合适的选择。

##### 2. IO模型

现代操作系统都包括内核空间和用户空间，其中，内核空间主要存放内核代码和数据，供系统进程使用，用户空间主要存放用户代码和数据，是供用户进程使用。

一般，IO操作都有类似如下两个阶段，第一阶段，当数据分组到来时，将其拷贝到内核空间的临时缓存区，第二个阶段，再将内存空间临时缓存区中的数据复制到用户空间缓存区。围绕着这两个阶段，存在这一下几种主流的IO操作模式：

阻塞IO：

所有的套接口都是阻塞的，意味着IO的发起和结束都需等待，任何一个系统调用都会产生一个由用户态到内核态切换，在从内核态到用户态的一个切换过程，而进程的上下文切换也是通过系统中断程序来实现的，需要保存当前进程的上下文，这是一个成本很高的过程。

- 非阻塞IO：

把套接口设置成非阻塞时，用户进程会不停的询问某种操作是否准备就绪，轮询方式，这是种比较浪费CPU的方式。

- IO复用：

主要依赖于操作系统提供的select和poll机制，这是阻塞进程是在这两个系统调用上，不在真正的IO操作上，IO操作看起来复用阻塞了两次，但是第一次阻塞是在select上监控多个套接口是否已有IO操作准备就绪，加大了性能指标。

- 信号驱动IO：

通过sigaction系统调用注册一个信号处理程序，主程序可以继续向下执行，当所监控的套接口有IO操作准备就绪的时候，由内核触发通知前面的注册信号处理程序执行，将数据从内核空间复制到用户空间。

- 异步IO：

与信号驱动IO的区别是直接由内核告诉IO操作何时完成了。可以看到，前四种IO模型的主要区别是在第一阶段，因为它们第二阶段都是在阻塞等待数据由内核空间复制到用户空间；而异步IO在第一阶段和第二阶段都不会阻塞。

##### 3.可靠性

常见的网络通信保障手段包括链路有效性检测以及断线以后的重连处理。

**链路有效性检测**

要确保通信链路的可靠性就必须对链路进行周期性的有效性检测，通用的做法就是心跳检测，通常有两种技术实现方式：

一种是在TCP层通过建立长连接在发送端和接收端之间传递心跳信息；

另一种则是在应用层，心跳信息根据系统要求可能包含一定的业务逻辑。

**重连处理**

当发送方检测到通信链路中断，会在事先约定好的重连间隔时间之后发起重连操作，如果重连失败，则周期性地使用该间隔时间进行重连直至重连成功。

##### 4. 同步与异步

通信中的两种基本方式，一种是请求应答模式的同步操作，一种是单向模式的异步操作。同步调用会造成业务线程阻塞，但开发和管理相对简单。异步调用的目的在于获取高性能，队列思想和事件驱动都是实现异步调用的常见策略，但都主要依赖于基础中间件平台。JDK也为我们提供了Future模式实现异步调用。Future模式调用可以进一步分为两种模式，Future-Get模式和Future-Listener模式，Future-Get模式通过主动get方式获取Future结果，但是get过程是串行的，会造成执行get方法的线程形成阻塞，Future-Listener模式中需要创建Listener，当Future结果生成时唤醒注册该Future上的Listener对象，从而形成异步回调机制。
